# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T10:07:33+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class AccessDeniedException(RootModel[Any]):
    root: Any


class AccountId(RootModel[constr(pattern=r'[0-9]{12}', min_length=12, max_length=12)]):
    root: constr(pattern=r'[0-9]{12}', min_length=12, max_length=12)


class AllowPublish(Enum):
    ALLOW = 'ALLOW'
    BLOCK = 'BLOCK'


class AllowUpstream(Enum):
    ALLOW = 'ALLOW'
    BLOCK = 'BLOCK'


class Arn(RootModel[constr(pattern=r'\S+', min_length=1, max_length=1011)]):
    root: constr(pattern=r'\S+', min_length=1, max_length=1011)


class Asset(RootModel[str]):
    root: str


class AssetName(RootModel[constr(pattern=r'\P{C}+', min_length=1, max_length=255)]):
    root: constr(pattern=r'\P{C}+', min_length=1, max_length=255)


class AssociateExternalConnectionRequest(BaseModel):
    pass


class AuthorizationTokenDurationSeconds(RootModel[conint(ge=0, le=43200)]):
    root: conint(ge=0, le=43200)


class BooleanOptional(RootModel[bool]):
    root: bool


class ConflictException(RootModel[Any]):
    root: Any


class DeleteDomainPermissionsPolicyRequest(BaseModel):
    pass


class DeleteDomainRequest(BaseModel):
    pass


class DeletePackageRequest(BaseModel):
    pass


class DeleteRepositoryPermissionsPolicyRequest(BaseModel):
    pass


class DeleteRepositoryRequest(BaseModel):
    pass


class DescribeDomainRequest(BaseModel):
    pass


class DescribePackageRequest(BaseModel):
    pass


class DescribePackageVersionRequest(BaseModel):
    pass


class DescribeRepositoryRequest(BaseModel):
    pass


class Description(RootModel[constr(pattern=r'\P{C}*', max_length=1000)]):
    root: constr(pattern=r'\P{C}*', max_length=1000)


class DisassociateExternalConnectionRequest(BaseModel):
    pass


class DomainName(
    RootModel[
        constr(pattern=r'[a-z][a-z0-9\-]{0,48}[a-z0-9]', min_length=2, max_length=50)
    ]
):
    root: constr(pattern=r'[a-z][a-z0-9\-]{0,48}[a-z0-9]', min_length=2, max_length=50)


class DomainStatus(Enum):
    Active = 'Active'
    Deleted = 'Deleted'


class ErrorMessage(RootModel[str]):
    root: str


class ExternalConnectionName(
    RootModel[
        constr(
            pattern=r'[A-Za-z0-9][A-Za-z0-9._\-:]{1,99}', min_length=2, max_length=100
        )
    ]
):
    root: constr(
        pattern=r'[A-Za-z0-9][A-Za-z0-9._\-:]{1,99}', min_length=2, max_length=100
    )


class ExternalConnectionStatus(Enum):
    Available = 'Available'


class GetAuthorizationTokenRequest(BaseModel):
    pass


class GetDomainPermissionsPolicyRequest(BaseModel):
    pass


class GetPackageVersionAssetRequest(BaseModel):
    pass


class GetPackageVersionAssetResult(BaseModel):
    asset: Optional[Asset] = None


class GetPackageVersionReadmeRequest(BaseModel):
    pass


class GetRepositoryEndpointRequest(BaseModel):
    pass


class GetRepositoryPermissionsPolicyRequest(BaseModel):
    pass


class HashAlgorithm(Enum):
    MD5 = 'MD5'
    SHA_1 = 'SHA-1'
    SHA_256 = 'SHA-256'
    SHA_512 = 'SHA-512'


class HashValue(RootModel[constr(pattern=r'[0-9a-f]+', min_length=32, max_length=512)]):
    root: constr(pattern=r'[0-9a-f]+', min_length=32, max_length=512)


class Integer(RootModel[int]):
    root: int


class InternalServerException(RootModel[Any]):
    root: Any


class ListDomainsMaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ListPackageVersionAssetsMaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ListPackageVersionAssetsRequest(BaseModel):
    pass


class ListPackageVersionDependenciesRequest(BaseModel):
    pass


class ListPackageVersionsMaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ListPackageVersionsRequest(BaseModel):
    pass


class ListPackagesMaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ListPackagesRequest(BaseModel):
    pass


class ListRepositoriesInDomainMaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ListRepositoriesInDomainRequest(BaseModel):
    pass


class ListRepositoriesMaxResults(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class ListRepositoriesRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class Long(RootModel[int]):
    root: int


class LongOptional(RootModel[int]):
    root: int


class PackageFormat(Enum):
    npm = 'npm'
    pypi = 'pypi'
    maven = 'maven'
    nuget = 'nuget'
    generic = 'generic'


class PackageName(RootModel[constr(pattern=r'[^#/\s]+', min_length=1, max_length=255)]):
    root: constr(pattern=r'[^#/\s]+', min_length=1, max_length=255)


class PackageNamespace(
    RootModel[constr(pattern=r'[^#/\s]+', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[^#/\s]+', min_length=1, max_length=255)


class PackageOriginRestrictions(BaseModel):
    publish: AllowPublish
    upstream: AllowUpstream


class PackageVersion(
    RootModel[constr(pattern=r'[^#/\s]+', min_length=1, max_length=255)]
):
    root: constr(pattern=r'[^#/\s]+', min_length=1, max_length=255)


class PackageVersionErrorCode(Enum):
    ALREADY_EXISTS = 'ALREADY_EXISTS'
    MISMATCHED_REVISION = 'MISMATCHED_REVISION'
    MISMATCHED_STATUS = 'MISMATCHED_STATUS'
    NOT_ALLOWED = 'NOT_ALLOWED'
    NOT_FOUND = 'NOT_FOUND'
    SKIPPED = 'SKIPPED'


class PackageVersionList(RootModel[List[PackageVersion]]):
    root: List[PackageVersion] = Field(..., max_length=100)


class PackageVersionOriginType(Enum):
    INTERNAL = 'INTERNAL'
    EXTERNAL = 'EXTERNAL'
    UNKNOWN = 'UNKNOWN'


class PackageVersionRevision(
    RootModel[constr(pattern=r'\S+', min_length=1, max_length=50)]
):
    root: constr(pattern=r'\S+', min_length=1, max_length=50)


class PackageVersionRevisionMap(RootModel[Optional[Dict[str, PackageVersionRevision]]]):
    root: Optional[Dict[str, PackageVersionRevision]] = None


class PackageVersionSortType(Enum):
    PUBLISHED_TIME = 'PUBLISHED_TIME'


class PackageVersionStatus(Enum):
    Published = 'Published'
    Unfinished = 'Unfinished'
    Unlisted = 'Unlisted'
    Archived = 'Archived'
    Disposed = 'Disposed'
    Deleted = 'Deleted'


class PaginationToken(RootModel[constr(pattern=r'\S+', min_length=1, max_length=2000)]):
    root: constr(pattern=r'\S+', min_length=1, max_length=2000)


class PolicyDocument(
    RootModel[constr(pattern=r'[\P{C}\s]+', min_length=1, max_length=7168)]
):
    root: constr(pattern=r'[\P{C}\s]+', min_length=1, max_length=7168)


class PolicyRevision(RootModel[constr(pattern=r'\S+', min_length=1, max_length=100)]):
    root: constr(pattern=r'\S+', min_length=1, max_length=100)


class PublishPackageVersionRequest(BaseModel):
    assetContent: Asset


class PutDomainPermissionsPolicyRequest(BaseModel):
    domain: DomainName
    domainOwner: Optional[AccountId] = None
    policyDocument: PolicyDocument
    policyRevision: Optional[PolicyRevision] = None


class PutPackageOriginConfigurationRequest(BaseModel):
    restrictions: PackageOriginRestrictions


class PutRepositoryPermissionsPolicyRequest(BaseModel):
    policyDocument: PolicyDocument
    policyRevision: Optional[PolicyRevision] = None


class RepositoryExternalConnectionInfo(BaseModel):
    externalConnectionName: Optional[ExternalConnectionName] = None
    packageFormat: Optional[PackageFormat] = None
    status: Optional[ExternalConnectionStatus] = None


class RepositoryExternalConnectionInfoList(
    RootModel[List[RepositoryExternalConnectionInfo]]
):
    root: List[RepositoryExternalConnectionInfo]


class RepositoryName(
    RootModel[
        constr(
            pattern=r'[A-Za-z0-9][A-Za-z0-9._\-]{1,99}', min_length=2, max_length=100
        )
    ]
):
    root: constr(
        pattern=r'[A-Za-z0-9][A-Za-z0-9._\-]{1,99}', min_length=2, max_length=100
    )


class ResourceNotFoundException(RootModel[Any]):
    root: Any


class ResourcePolicy(BaseModel):
    document: Optional[PolicyDocument] = None
    resourceArn: Optional[Arn] = None
    revision: Optional[PolicyRevision] = None


class SHA256(RootModel[constr(pattern=r'[0-9a-f]+', min_length=64, max_length=64)]):
    root: constr(pattern=r'[0-9a-f]+', min_length=64, max_length=64)


class ServiceQuotaExceededException(RootModel[Any]):
    root: Any


class String(RootModel[str]):
    root: str


class String255(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class SuccessfulPackageVersionInfo(BaseModel):
    revision: Optional[String] = None
    status: Optional[PackageVersionStatus] = None


class SuccessfulPackageVersionInfoMap(
    RootModel[Optional[Dict[str, SuccessfulPackageVersionInfo]]]
):
    root: Optional[Dict[str, SuccessfulPackageVersionInfo]] = None


class TagKey(RootModel[constr(pattern=r'\P{C}+', min_length=1, max_length=128)]):
    root: constr(pattern=r'\P{C}+', min_length=1, max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=200, min_length=0)


class TagResourceResult(BaseModel):
    pass


class TagValue(RootModel[constr(pattern=r'\P{C}*', min_length=0, max_length=256)]):
    root: constr(pattern=r'\P{C}*', min_length=0, max_length=256)


class ThrottlingException(RootModel[Any]):
    root: Any


class Timestamp(RootModel[datetime]):
    root: datetime


class UntagResourceRequest(BaseModel):
    tagKeys: TagKeyList


class UntagResourceResult(BaseModel):
    pass


class UpdatePackageVersionsStatusRequest(BaseModel):
    expectedStatus: Optional[PackageVersionStatus] = None
    targetStatus: PackageVersionStatus
    versionRevisions: Optional[PackageVersionRevisionMap] = None
    versions: PackageVersionList


class UpstreamRepository(BaseModel):
    repositoryName: RepositoryName


class UpstreamRepositoryInfo(BaseModel):
    repositoryName: Optional[RepositoryName] = None


class UpstreamRepositoryInfoList(RootModel[List[UpstreamRepositoryInfo]]):
    root: List[UpstreamRepositoryInfo]


class UpstreamRepositoryList(RootModel[List[UpstreamRepository]]):
    root: List[UpstreamRepository]


class ValidationException(RootModel[Any]):
    root: Any


class V1DomainPermissionsPolicyPutRequest(BaseModel):
    domain: constr(
        pattern=r'[a-z][a-z0-9\-]{0,48}[a-z0-9]', min_length=2, max_length=50
    ) = Field(
        ..., description=' The name of the domain on which to set the resource policy. '
    )
    domainOwner: Optional[
        constr(pattern=r'[0-9]{12}', min_length=12, max_length=12)
    ] = Field(
        None,
        description=' The 12-digit account number of the Amazon Web Services account that owns the domain. It does not include dashes or spaces. ',
    )
    policyDocument: constr(pattern=r'[\P{C}\s]+', min_length=1, max_length=7168) = (
        Field(
            ...,
            description=' A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided domain. ',
        )
    )
    policyRevision: Optional[constr(pattern=r'\S+', min_length=1, max_length=100)] = (
        Field(
            None,
            description=" The current revision of the resource policy to be set. This revision is used for optimistic locking, which prevents others from overwriting your changes to the domain's resource policy. ",
        )
    )


class V1DomainsPostRequest(BaseModel):
    maxResults: Optional[conint(ge=1, le=1000)] = Field(
        None, description=' The maximum number of results to return per page. '
    )
    nextToken: Optional[constr(pattern=r'\S+', min_length=1, max_length=2000)] = Field(
        None,
        description=' The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results. ',
    )


class Format(Enum):
    npm = 'npm'
    pypi = 'pypi'
    maven = 'maven'
    nuget = 'nuget'
    generic = 'generic'


class Restrictions(BaseModel):
    publish: Optional[AllowPublish] = None
    upstream: Optional[AllowUpstream] = None


class V1PackageDomainRepositoryFormatPackagePostRequest(BaseModel):
    restrictions: Restrictions = Field(
        ...,
        description='Details about the origin restrictions set on the package. The package origin restrictions determine how new versions of a package can be added to a specific repository.',
    )


class V1PackageVersionPublishDomainRepositoryFormatPackageVersionAssetXAmzContentSha256PostRequest(
    BaseModel
):
    assetContent: str = Field(..., description='The content of the asset to publish.')


class Status(Enum):
    Published = 'Published'
    Unfinished = 'Unfinished'
    Unlisted = 'Unlisted'
    Archived = 'Archived'
    Disposed = 'Disposed'
    Deleted = 'Deleted'


class SortBy(Enum):
    PUBLISHED_TIME = 'PUBLISHED_TIME'


class OriginType(Enum):
    INTERNAL = 'INTERNAL'
    EXTERNAL = 'EXTERNAL'
    UNKNOWN = 'UNKNOWN'


class V1PackageVersionsCopyDomainSourceRepositoryDestinationRepositoryFormatPackagePostRequest(
    BaseModel
):
    allowOverwrite: Optional[bool] = Field(
        None,
        description=' Set to true to overwrite a package version that already exists in the destination repository. If set to false and the package version already exists in the destination repository, the package version is returned in the <code>failedVersions</code> field of the response with an <code>ALREADY_EXISTS</code> error code. ',
    )
    includeFromUpstream: Optional[bool] = Field(
        None,
        description=' Set to true to copy packages from repositories that are upstream from the source repository to the destination repository. The default setting is false. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. ',
    )
    versionRevisions: Optional[Dict[str, PackageVersionRevision]] = Field(
        None,
        description='<p> A list of key-value pairs. The keys are package versions and the values are package version revisions. A <code>CopyPackageVersion</code> operation succeeds if the specified versions in the source repository match the specified package version revision. </p> <note> <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p> </note>',
    )
    versions: Optional[List[PackageVersion]] = Field(
        None,
        description='<p> The versions of the package to be copied. </p> <note> <p> You must specify <code>versions</code> or <code>versionRevisions</code>. You cannot specify both. </p> </note>',
        max_length=100,
    )


class ExpectedStatus(Enum):
    Published = 'Published'
    Unfinished = 'Unfinished'
    Unlisted = 'Unlisted'
    Archived = 'Archived'
    Disposed = 'Disposed'
    Deleted = 'Deleted'


class V1PackageVersionsDeleteDomainRepositoryFormatPackagePostRequest(BaseModel):
    expectedStatus: Optional[ExpectedStatus] = Field(
        None, description=' The expected status of the package version to delete. '
    )
    versions: List[PackageVersion] = Field(
        ...,
        description=' An array of strings that specify the versions of the package to delete. ',
        max_length=100,
    )


class V1PackageVersionsDisposeDomainRepositoryFormatPackagePostRequest(BaseModel):
    expectedStatus: Optional[ExpectedStatus] = Field(
        None, description=' The expected status of the package version to dispose. '
    )
    versionRevisions: Optional[Dict[str, PackageVersionRevision]] = Field(
        None, description=' The revisions of the package versions you want to dispose. '
    )
    versions: List[PackageVersion] = Field(
        ...,
        description=' The versions of the package you want to dispose. ',
        max_length=100,
    )


class TargetStatus(Enum):
    Published = 'Published'
    Unfinished = 'Unfinished'
    Unlisted = 'Unlisted'
    Archived = 'Archived'
    Disposed = 'Disposed'
    Deleted = 'Deleted'


class V1PackageVersionsUpdateStatusDomainRepositoryFormatPackagePostRequest(BaseModel):
    expectedStatus: Optional[ExpectedStatus] = Field(
        None,
        description=" The package version’s expected status before it is updated. If <code>expectedStatus</code> is provided, the package version's status is updated only if its status at the time <code>UpdatePackageVersionsStatus</code> is called matches <code>expectedStatus</code>. ",
    )
    targetStatus: TargetStatus = Field(
        ...,
        description=' The status you want to change the package version status to. ',
    )
    versionRevisions: Optional[Dict[str, PackageVersionRevision]] = Field(
        None,
        description=' A map of package versions and package version revisions. The map <code>key</code> is the package version (for example, <code>3.5.2</code>), and the map <code>value</code> is the package version revision. ',
    )
    versions: List[PackageVersion] = Field(
        ...,
        description=' An array of strings that specify the versions of the package with the statuses to update. ',
        max_length=100,
    )


class Publish(Enum):
    ALLOW = 'ALLOW'
    BLOCK = 'BLOCK'


class Upstream(Enum):
    ALLOW = 'ALLOW'
    BLOCK = 'BLOCK'


class V1RepositoryDomainRepositoryPutRequest(BaseModel):
    description: Optional[constr(pattern=r'\P{C}*', max_length=1000)] = Field(
        None, description=' An updated repository description. '
    )
    upstreams: Optional[List[UpstreamRepository]] = Field(
        None,
        description=' A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. ',
    )


class V1RepositoryPermissionsPolicyDomainRepositoryPutRequest(BaseModel):
    policyDocument: constr(pattern=r'[\P{C}\s]+', min_length=1, max_length=7168) = (
        Field(
            ...,
            description=' A valid displayable JSON Aspen policy string to be set as the access control resource policy on the provided repository. ',
        )
    )
    policyRevision: Optional[constr(pattern=r'\S+', min_length=1, max_length=100)] = (
        Field(
            None,
            description=" Sets the revision of the resource policy that specifies permissions to access the repository. This revision is used for optimistic locking, which prevents others from overwriting your changes to the repository's resource policy. ",
        )
    )


class V1UntagResourceArnPostRequest(BaseModel):
    tagKeys: List[TagKey] = Field(
        ...,
        description='The tag key for each tag that you want to remove from the resource.',
        max_length=200,
        min_length=0,
    )


class AssetHashes(RootModel[Optional[Dict[str, HashValue]]]):
    root: Optional[Dict[str, HashValue]] = None


class AssetSummary(BaseModel):
    hashes: Optional[AssetHashes] = None
    name: AssetName
    size: Optional[LongOptional] = None


class AssetSummaryList(RootModel[List[AssetSummary]]):
    root: List[AssetSummary]


class CopyPackageVersionsRequest(BaseModel):
    allowOverwrite: Optional[BooleanOptional] = None
    includeFromUpstream: Optional[BooleanOptional] = None
    versionRevisions: Optional[PackageVersionRevisionMap] = None
    versions: Optional[PackageVersionList] = None


class DeleteDomainPermissionsPolicyResult(BaseModel):
    policy: Optional[ResourcePolicy] = None


class DeletePackageVersionsRequest(BaseModel):
    expectedStatus: Optional[PackageVersionStatus] = None
    versions: PackageVersionList


class DeleteRepositoryPermissionsPolicyResult(BaseModel):
    policy: Optional[ResourcePolicy] = None


class DisposePackageVersionsRequest(BaseModel):
    expectedStatus: Optional[PackageVersionStatus] = None
    versionRevisions: Optional[PackageVersionRevisionMap] = None
    versions: PackageVersionList


class DomainDescription(BaseModel):
    arn: Optional[Arn] = None
    assetSizeBytes: Optional[Long] = None
    createdTime: Optional[Timestamp] = None
    encryptionKey: Optional[Arn] = None
    name: Optional[DomainName] = None
    owner: Optional[AccountId] = None
    repositoryCount: Optional[Integer] = None
    s3BucketArn: Optional[Arn] = None
    status: Optional[DomainStatus] = None


class DomainEntryPoint(BaseModel):
    externalConnectionName: Optional[ExternalConnectionName] = None
    repositoryName: Optional[RepositoryName] = None


class DomainSummary(BaseModel):
    arn: Optional[Arn] = None
    createdTime: Optional[Timestamp] = None
    encryptionKey: Optional[Arn] = None
    name: Optional[DomainName] = None
    owner: Optional[AccountId] = None
    status: Optional[DomainStatus] = None


class DomainSummaryList(RootModel[List[DomainSummary]]):
    root: List[DomainSummary]


class GetAuthorizationTokenResult(BaseModel):
    authorizationToken: Optional[String] = None
    expiration: Optional[Timestamp] = None


class GetDomainPermissionsPolicyResult(BaseModel):
    policy: Optional[ResourcePolicy] = None


class GetPackageVersionReadmeResult(BaseModel):
    format: Optional[PackageFormat] = None
    namespace: Optional[PackageNamespace] = None
    package: Optional[PackageName] = None
    readme: Optional[String] = None
    version: Optional[PackageVersion] = None
    versionRevision: Optional[PackageVersionRevision] = None


class GetRepositoryEndpointResult(BaseModel):
    repositoryEndpoint: Optional[String] = None


class GetRepositoryPermissionsPolicyResult(BaseModel):
    policy: Optional[ResourcePolicy] = None


class LicenseInfo(BaseModel):
    name: Optional[String] = None
    url: Optional[String] = None


class LicenseInfoList(RootModel[List[LicenseInfo]]):
    root: List[LicenseInfo]


class ListDomainsRequest(BaseModel):
    maxResults: Optional[ListDomainsMaxResults] = None
    nextToken: Optional[PaginationToken] = None


class ListDomainsResult(BaseModel):
    domains: Optional[DomainSummaryList] = None
    nextToken: Optional[PaginationToken] = None


class ListPackageVersionAssetsResult(BaseModel):
    assets: Optional[AssetSummaryList] = None
    format: Optional[PackageFormat] = None
    namespace: Optional[PackageNamespace] = None
    nextToken: Optional[PaginationToken] = None
    package: Optional[PackageName] = None
    version: Optional[PackageVersion] = None
    versionRevision: Optional[PackageVersionRevision] = None


class PackageDependency(BaseModel):
    dependencyType: Optional[String] = None
    namespace: Optional[PackageNamespace] = None
    package: Optional[PackageName] = None
    versionRequirement: Optional[String] = None


class PackageDependencyList(RootModel[List[PackageDependency]]):
    root: List[PackageDependency]


class PackageOriginConfiguration(BaseModel):
    restrictions: Optional[PackageOriginRestrictions] = None


class PackageSummary(BaseModel):
    format: Optional[PackageFormat] = None
    namespace: Optional[PackageNamespace] = None
    originConfiguration: Optional[PackageOriginConfiguration] = None
    package: Optional[PackageName] = None


class PackageSummaryList(RootModel[List[PackageSummary]]):
    root: List[PackageSummary]


class PackageVersionError(BaseModel):
    errorCode: Optional[PackageVersionErrorCode] = None
    errorMessage: Optional[ErrorMessage] = None


class PackageVersionErrorMap(RootModel[Optional[Dict[str, PackageVersionError]]]):
    root: Optional[Dict[str, PackageVersionError]] = None


class PackageVersionOrigin(BaseModel):
    domainEntryPoint: Optional[DomainEntryPoint] = None
    originType: Optional[PackageVersionOriginType] = None


class PackageVersionSummary(BaseModel):
    origin: Optional[PackageVersionOrigin] = None
    revision: Optional[PackageVersionRevision] = None
    status: PackageVersionStatus
    version: PackageVersion


class PackageVersionSummaryList(RootModel[List[PackageVersionSummary]]):
    root: List[PackageVersionSummary]


class PublishPackageVersionResult(BaseModel):
    asset: Optional[AssetSummary] = None
    format: Optional[PackageFormat] = None
    namespace: Optional[PackageNamespace] = None
    package: Optional[PackageName] = None
    status: Optional[PackageVersionStatus] = None
    version: Optional[PackageVersion] = None
    versionRevision: Optional[PackageVersionRevision] = None


class PutDomainPermissionsPolicyResult(BaseModel):
    policy: Optional[ResourcePolicy] = None


class PutPackageOriginConfigurationResult(BaseModel):
    originConfiguration: Optional[PackageOriginConfiguration] = None


class PutRepositoryPermissionsPolicyResult(BaseModel):
    policy: Optional[ResourcePolicy] = None


class RepositoryDescription(BaseModel):
    administratorAccount: Optional[AccountId] = None
    arn: Optional[Arn] = None
    createdTime: Optional[Timestamp] = None
    description: Optional[Description] = None
    domainName: Optional[DomainName] = None
    domainOwner: Optional[AccountId] = None
    externalConnections: Optional[RepositoryExternalConnectionInfoList] = None
    name: Optional[RepositoryName] = None
    upstreams: Optional[UpstreamRepositoryInfoList] = None


class RepositorySummary(BaseModel):
    administratorAccount: Optional[AccountId] = None
    arn: Optional[Arn] = None
    createdTime: Optional[Timestamp] = None
    description: Optional[Description] = None
    domainName: Optional[DomainName] = None
    domainOwner: Optional[AccountId] = None
    name: Optional[RepositoryName] = None


class RepositorySummaryList(RootModel[List[RepositorySummary]]):
    root: List[RepositorySummary]


class Tag(BaseModel):
    key: TagKey
    value: TagValue


class TagList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=200, min_length=0)


class TagResourceRequest(BaseModel):
    tags: TagList


class UpdatePackageVersionsStatusResult(BaseModel):
    failedVersions: Optional[PackageVersionErrorMap] = None
    successfulVersions: Optional[SuccessfulPackageVersionInfoMap] = None


class UpdateRepositoryRequest(BaseModel):
    description: Optional[Description] = None
    upstreams: Optional[UpstreamRepositoryList] = None


class UpdateRepositoryResult(BaseModel):
    repository: Optional[RepositoryDescription] = None


class V1DomainDomainPostRequest(BaseModel):
    encryptionKey: Optional[constr(pattern=r'\S+', min_length=1, max_length=1011)] = (
        Field(
            None,
            description='<p> The encryption key for the domain. This is used to encrypt content stored in a domain. An encryption key can be a key ID, a key Amazon Resource Name (ARN), a key alias, or a key alias ARN. To specify an <code>encryptionKey</code>, your IAM role must have <code>kms:DescribeKey</code> and <code>kms:CreateGrant</code> permissions on the encryption key that is used. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestSyntax">DescribeKey</a> in the <i>Key Management Service API Reference</i> and <a href="https://docs.aws.amazon.com/kms/latest/developerguide/kms-api-permissions-reference.html">Key Management Service API Permissions Reference</a> in the <i>Key Management Service Developer Guide</i>. </p> <important> <p> CodeArtifact supports only symmetric CMKs. Do not associate an asymmetric CMK with your domain. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using symmetric and asymmetric keys</a> in the <i>Key Management Service Developer Guide</i>. </p> </important>',
        )
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='One or more tag key-value pairs for the domain.',
        max_length=200,
        min_length=0,
    )


class V1RepositoryDomainRepositoryPostRequest(BaseModel):
    description: Optional[constr(pattern=r'\P{C}*', max_length=1000)] = Field(
        None, description=' A description of the created repository. '
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='One or more tag key-value pairs for the repository.',
        max_length=200,
        min_length=0,
    )
    upstreams: Optional[List[UpstreamRepository]] = Field(
        None,
        description=' A list of upstream repositories to associate with the repository. The order of the upstream repositories in the list determines their priority order when CodeArtifact looks for a requested package version. For more information, see <a href="https://docs.aws.amazon.com/codeartifact/latest/ug/repos-upstream.html">Working with upstream repositories</a>. ',
    )


class V1TagResourceArnPostRequest(BaseModel):
    tags: List[Tag] = Field(
        ...,
        description='The tags you want to modify or add to the resource.',
        max_length=200,
        min_length=0,
    )


class AssociateExternalConnectionResult(BaseModel):
    repository: Optional[RepositoryDescription] = None


class CopyPackageVersionsResult(BaseModel):
    failedVersions: Optional[PackageVersionErrorMap] = None
    successfulVersions: Optional[SuccessfulPackageVersionInfoMap] = None


class CreateDomainRequest(BaseModel):
    encryptionKey: Optional[Arn] = None
    tags: Optional[TagList] = None


class CreateDomainResult(BaseModel):
    domain: Optional[DomainDescription] = None


class CreateRepositoryRequest(BaseModel):
    description: Optional[Description] = None
    tags: Optional[TagList] = None
    upstreams: Optional[UpstreamRepositoryList] = None


class CreateRepositoryResult(BaseModel):
    repository: Optional[RepositoryDescription] = None


class DeleteDomainResult(BaseModel):
    domain: Optional[DomainDescription] = None


class DeletePackageResult(BaseModel):
    deletedPackage: Optional[PackageSummary] = None


class DeletePackageVersionsResult(BaseModel):
    failedVersions: Optional[PackageVersionErrorMap] = None
    successfulVersions: Optional[SuccessfulPackageVersionInfoMap] = None


class DeleteRepositoryResult(BaseModel):
    repository: Optional[RepositoryDescription] = None


class DescribeDomainResult(BaseModel):
    domain: Optional[DomainDescription] = None


class DescribeRepositoryResult(BaseModel):
    repository: Optional[RepositoryDescription] = None


class DisassociateExternalConnectionResult(BaseModel):
    repository: Optional[RepositoryDescription] = None


class DisposePackageVersionsResult(BaseModel):
    failedVersions: Optional[PackageVersionErrorMap] = None
    successfulVersions: Optional[SuccessfulPackageVersionInfoMap] = None


class ListPackageVersionDependenciesResult(BaseModel):
    dependencies: Optional[PackageDependencyList] = None
    format: Optional[PackageFormat] = None
    namespace: Optional[PackageNamespace] = None
    nextToken: Optional[PaginationToken] = None
    package: Optional[PackageName] = None
    version: Optional[PackageVersion] = None
    versionRevision: Optional[PackageVersionRevision] = None


class ListPackageVersionsResult(BaseModel):
    defaultDisplayVersion: Optional[PackageVersion] = None
    format: Optional[PackageFormat] = None
    namespace: Optional[PackageNamespace] = None
    nextToken: Optional[PaginationToken] = None
    package: Optional[PackageName] = None
    versions: Optional[PackageVersionSummaryList] = None


class ListPackagesResult(BaseModel):
    nextToken: Optional[PaginationToken] = None
    packages: Optional[PackageSummaryList] = None


class ListRepositoriesInDomainResult(BaseModel):
    nextToken: Optional[PaginationToken] = None
    repositories: Optional[RepositorySummaryList] = None


class ListRepositoriesResult(BaseModel):
    nextToken: Optional[PaginationToken] = None
    repositories: Optional[RepositorySummaryList] = None


class ListTagsForResourceResult(BaseModel):
    tags: Optional[TagList] = None


class PackageDescription(BaseModel):
    format: Optional[PackageFormat] = None
    name: Optional[PackageName] = None
    namespace: Optional[PackageNamespace] = None
    originConfiguration: Optional[PackageOriginConfiguration] = None


class PackageVersionDescription(BaseModel):
    displayName: Optional[String255] = None
    format: Optional[PackageFormat] = None
    homePage: Optional[String] = None
    licenses: Optional[LicenseInfoList] = None
    namespace: Optional[PackageNamespace] = None
    origin: Optional[PackageVersionOrigin] = None
    packageName: Optional[PackageName] = None
    publishedTime: Optional[Timestamp] = None
    revision: Optional[PackageVersionRevision] = None
    sourceCodeRepository: Optional[String] = None
    status: Optional[PackageVersionStatus] = None
    summary: Optional[String] = None
    version: Optional[PackageVersion] = None


class DescribePackageResult(BaseModel):
    package: PackageDescription


class DescribePackageVersionResult(BaseModel):
    packageVersion: PackageVersionDescription
